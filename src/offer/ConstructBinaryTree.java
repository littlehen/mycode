package offer;

import java.util.Arrays;

/* 重建二叉树
  * 问题描述：输入某二叉树的前序遍历和中序遍历结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中
  * 都不包含重复的数字。例如输入前序遍历序列:{1,2,4,7,3,5,6,8}和中序遍历{4,7,2,1,5,3,8,6},
  * 则重建出图中所示二叉树并且输出它的头结点。
  */

//定义节点

public class ConstructBinaryTree {
	 static class TreeNode {
	     int val;
	     TreeNode left;
	     TreeNode right;
	     TreeNode(int x) { val = x; }
	 }
	public static TreeNode reConstructBinaryTree(int [] pre,int [] in) {
	    if (pre == null || in == null) {
	        return null;
	    }
	    if (pre.length == 0 || in.length == 0) {
	        return null;
	    }
	    if (pre.length != in.length) {
	        return null;
	    }
	    TreeNode root = new TreeNode(pre[0]);
	    for (int i = 0; i < pre.length; i++) {
	        if (pre[0] == in[i]) {
	            root.left = reConstructBinaryTree(
	                            Arrays.copyOfRange(pre,1,i+1),Arrays.copyOfRange(in,0,i));
	            root.right = reConstructBinaryTree(
	            Arrays.copyOfRange(pre,i+1,pre.length),Arrays.copyOfRange(in,i+1,in.length));
	        }
	    }
	    return root;
	}

	 // 按照前序遍历打印二叉树的节点
    public static void printPreBinaryTree(TreeNode root) {
        if (root == null) {
            return;
        } else {
            System.out.println(root.val + " ");
        }
        if (root.left != null) {
            printPreBinaryTree(root.left);
        }
        if (root.right != null) {
            printPreBinaryTree(root.right);
        }
    }
	
	public static void main(String[] args) throws Exception {
        int preOrder[] = { 1, 2, 4, 7, 3, 5, 6, 8 };
        int inOrder[] = { 4, 7, 2, 1, 5, 3, 8, 6 };
        ConstructBinaryTree test = new ConstructBinaryTree();
        printPreBinaryTree(reConstructBinaryTree(preOrder, inOrder));
    }
}
